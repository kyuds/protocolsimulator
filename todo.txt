Chord node class:
- finger table
    - start
    - interval
        - [finger[k].start, finger[k + 1].start]
            - finger[k].start = (n + 2^{k - 1}) mod 2^m 
            - m = # of bits for identifier circle
    - node
        - first node >= n.finger[k].start
- successor method
    - next node on identifier circle
- predecessor method
    - previous node on identifier circle
- hash function (SHA1?) -> for serializing node id

PoT node class:
- all node ids
    - separated into two lists: has spilled and doesn't have spill
    - try to do power of two on first list
- random sampling method?
- batch eviction (as noted in infiniswap)
- state changer

statcollector.py:
- record number of timesteps it takes for Chord vs PoT to find empty node
    - for now assume every operation is the same time? (e.g. chord asking one node's fingertable = PoT asking two random nodes)
    - 
- todo later
    - dictionaries to record node failures, evictions

Things to consider:
- identifier circle being completely full -> successor/predecessor method and .node in chord become pointless